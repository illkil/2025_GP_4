rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {
    function isSignedIn() { return request.auth != null; }

    // string must be <= max, not empty (unless allowEmpty) and no < >
    function strOk(s, max, allowEmpty) {
      return s is string
             && (allowEmpty ? s.size() >= 0 : s.size() > 0)
             && s.size() <= max
             && s.matches('^[^<>]*$');
    }

    // object contains ONLY allowed keys
    function hasOnlyKeys(allowed) {
      return request.resource.data.keys().hasOnly(allowed);
    }

    // changed keys are ONLY within allowed set
    function changedOnly(allowed) {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(allowed);
    }

    // optional simple phone sanity (digits, spaces, +, -, (), <=20)
    function phoneOk(p) {
      return p is string
             && p.size() <= 20
             && p.matches('^[0-9+()\\-\\s]*$');
    }

    // URL must be https and not a javascript: etc.
    function httpsUrl(u) {
      return u is string && u.size() <= 2000 && u.matches('^https://.*$');
    }

    // ---------- users ----------
    match /users/{uid} {
      allow read: if isSignedIn();

      allow create: if isSignedIn()
        && request.auth.uid == uid
        && hasOnlyKeys(['username','firstName','lastName','phone','photoUrl','createdAt','updatedAt'])
        && strOk(request.resource.data.username, 30, false)
        && (!('firstName' in request.resource.data) || strOk(request.resource.data.firstName, 30, false))
        && (!('lastName' in request.resource.data)  || strOk(request.resource.data.lastName, 30, false))
        && (!('phone' in request.resource.data)     || phoneOk(request.resource.data.phone))
        && (!('photoUrl' in request.resource.data)  || httpsUrl(request.resource.data.photoUrl))
        // enforce server timestamps on create
        && request.resource.data.createdAt == request.time
        && !('updatedAt' in request.resource.data);

      allow update: if isSignedIn()
        && request.auth.uid == uid
        // cannot add unexpected keys and can only change these fields
        && hasOnlyKeys(['username','firstName','lastName','phone','photoUrl','createdAt','updatedAt'])
        && changedOnly(['username','firstName','lastName','phone','photoUrl','updatedAt'])
        && (!('username' in request.resource.data) || strOk(request.resource.data.username, 30, false))
        && (!('firstName' in request.resource.data) || strOk(request.resource.data.firstName, 30, false))
        && (!('lastName' in request.resource.data)  || strOk(request.resource.data.lastName, 30, false))
        && (!('phone' in request.resource.data)     || phoneOk(request.resource.data.phone))
        && (!('photoUrl' in request.resource.data)  || httpsUrl(request.resource.data.photoUrl))
        // createdAt must be immutable; updatedAt must be server time
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.updatedAt == request.time;
    }

    // ---------- reports ----------
    // title: <=80, description: <=1000 (can be empty), location: <=120 (optional)
    // images: list<string url> (<=2), ownerId: uid, status in allowed set, createdAt server time
    match /reports/{id} {
      allow read: if isSignedIn();

      function imagesOk(images) {
        return images is list
               && images.size() <= 2
               && images.hasOnly(images.where(u => u is string && httpsUrl(u)));
      }

      function statusAllowed(s) {
        return s in ['submitted','matches_found','accepted','done','revoked','rejected','ongoing','expired'];
      }

      allow create: if isSignedIn()
        && hasOnlyKeys(['title','description','location','images','ownerId','status','createdAt','updatedAt'])
        && request.resource.data.ownerId == request.auth.uid
        && strOk(request.resource.data.title, 80, false)
        && (request.resource.data.description is string
            && request.resource.data.description.size() <= 1000
            && request.resource.data.description.matches('^[^<>]*$'))
        && (!('location' in request.resource.data) || strOk(request.resource.data.location, 120, true))
        && (!('images' in request.resource.data) || imagesOk(request.resource.data.images))
        && statusAllowed(request.resource.data.status)
        && request.resource.data.createdAt == request.time
        && !('updatedAt' in request.resource.data);

      // owner can edit limited fields; createdAt/ownerId immutable
      allow update: if isSignedIn()
        && resource.data.ownerId == request.auth.uid
        && hasOnlyKeys(['title','description','location','images','status','createdAt','ownerId','updatedAt'])
        && changedOnly(['title','description','location','images','status','updatedAt'])
        && strOk(request.resource.data.title, 80, false)
        && (request.resource.data.description is string
            && request.resource.data.description.size() <= 1000
            && request.resource.data.description.matches('^[^<>]*$'))
        && (!('location' in request.resource.data) || strOk(request.resource.data.location, 120, true))
        && (!('images' in request.resource.data) || imagesOk(request.resource.data.images))
        && (!('status' in request.resource.data) || statusAllowed(request.resource.data.status))
        && request.resource.data.ownerId == resource.data.ownerId
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.updatedAt == request.time;
    }

    // ---------- chats ----------
    // A chat is editable only by members. members must be 2+ unique UIDs
    match /chats/{chatId} {
      function membersOk(members) {
        return members is list
               && members.size() >= 2
               && members.size() == members.toSet().size() // unique
               && members.hasOnly(members.where(m => m is string));
      }

      allow read: if isSignedIn() && (resource.data.members hasAny [request.auth.uid]);

      allow create: if isSignedIn()
        && hasOnlyKeys(['members','createdAt','updatedAt'])
        && membersOk(request.resource.data.members)
        && (request.auth.uid in request.resource.data.members)
        && request.resource.data.createdAt == request.time
        && !('updatedAt' in request.resource.data);

      allow update: if isSignedIn()
        && (request.auth.uid in resource.data.members)
        && hasOnlyKeys(['members','createdAt','updatedAt'])
        && changedOnly(['members','updatedAt'])
        && membersOk(request.resource.data.members)
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.updatedAt == request.time;
    }

    // ---------- messages ----------
    match /chats/{chatId}/messages/{msgId} {
      allow read: if isSignedIn()
        && (get(/databases/$(db)/documents/chats/$(chatId)).data.members hasAny [request.auth.uid]);

      allow create: if isSignedIn()
        && hasOnlyKeys(['senderId','text','createdAt'])
        && request.resource.data.senderId == request.auth.uid
        && strOk(request.resource.data.text, 2000, true)
        && request.resource.data.createdAt == request.time
        // sender must be a chat member
        && (get(/databases/$(db)/documents/chats/$(chatId)).data.members hasAny [request.auth.uid]);
    }
  }
}
